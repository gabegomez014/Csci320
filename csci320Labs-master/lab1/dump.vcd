$date
	Wed Sep 12 16:05:03 2018
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module pb1TB $end
$var wire 32 ! res [31:0] $end
$var wire 32 " progcount [31:0] $end
$var wire 32 # memout [31:0] $end
$var wire 256 $ decoded [255:0] $end
$var reg 1 % clock $end
$scope module add $end
$var wire 32 & cur [31:0] $end
$var reg 32 ' counted [31:0] $end
$upscope $end
$scope module decoder_test $end
$var wire 32 ( inst [31:0] $end
$var reg 3 ) func3 [2:0] $end
$var reg 7 * func7 [6:0] $end
$var reg 12 + imm12 [11:0] $end
$var reg 7 , opcode [6:0] $end
$var reg 5 - rd [4:0] $end
$var reg 5 . rs1 [4:0] $end
$var reg 5 / rs2 [4:0] $end
$var reg 256 0 str [255:0] $end
$upscope $end
$scope module mem_test $end
$var wire 32 1 out [31:0] $end
$var wire 32 2 in [31:0] $end
$upscope $end
$scope module p_test $end
$var wire 1 % clock $end
$var wire 32 3 in [31:0] $end
$var reg 32 4 counter [31:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b1000000000000 4
b1000000000100 3
b1000000000000 2
b10100000000010100010011 1
b11011000110100100100000001000000010000001100001001000000011000000100000001000000010000000100000001000000010000000110101 0
b101 /
b0 .
b1010 -
b10011 ,
b101 +
b0 *
b0 )
b10100000000010100010011 (
b1000000000100 '
b1000000000000 &
0%
b11011000110100100100000001000000010000001100001001000000011000000100000001000000010000000100000001000000010000000110101 $
b10100000000010100010011 #
b1000000000000 "
b1000000000100 !
$end
#10
b1011 -
b1000000001000 !
b1000000001000 '
b1000000001000 3
b10100000000010110010011 #
b10100000000010110010011 (
b10100000000010110010011 1
b1000000000100 "
b1000000000100 &
b1000000000100 2
b1000000000100 4
1%
#20
0%
#30
b11000010110010001100100001000000010000000100000011000010011001000100000001000000010000001100001001100000010000000100000001000000110000100110001 $
b11000010110010001100100001000000010000000100000011000010011001000100000001000000010000001100001001100000010000000100000001000000110000100110001 0
b1011 +
b1011 /
b1010 .
b1100 -
b110011 ,
b1000000001100 !
b1000000001100 '
b1000000001100 3
b101101010000011000110011 #
b101101010000011000110011 (
b101101010000011000110011 1
b1000000001000 "
b1000000001000 &
b1000000001000 2
b1000000001000 4
1%
#40
0%
#50
b1100001011001000110010000100000001000000010000001100001001100000010000000100000001000000111101001100101011100100110111100100000001000000010000001111010011001010111001001101111 $
b1100001011001000110010000100000001000000010000001100001001100000010000000100000001000000111101001100101011100100110111100100000001000000010000001111010011001010111001001101111 0
b0 +
b0 /
b0 .
b1010 -
b1000000010000 !
b1000000010000 '
b1000000010000 3
b10100110011 #
b10100110011 (
b10100110011 1
b1000000001100 "
b1000000001100 &
b1000000001100 2
b1000000001100 4
1%
#60
0%
#70
b110010101100011011000010110110001101100 $
b110010101100011011000010110110001101100 0
b0 -
b1110011 ,
b1000000010100 !
b1000000010100 '
b1000000010100 3
b1110011 #
b1110011 (
b1110011 1
b1000000010000 "
b1000000010000 &
b1000000010000 2
b1000000010000 4
1%
#80
0%
#90
b0 ,
b1000000011000 !
b1000000011000 '
b1000000011000 3
b0 #
b0 (
b0 1
b1000000010100 "
b1000000010100 &
b1000000010100 2
b1000000010100 4
1%
#100
0%
